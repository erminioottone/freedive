<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CO₂ Training - Custom Static Apnea Trainer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; }
        #root { width: 100vw; min-height: 100vh; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Helper Functions ---
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        };

        const roundTime = (seconds) => {
            if (seconds <= 60) {
                return Math.round(seconds / 5) * 5;
            } else if (seconds <= 300) {
                return Math.round(seconds / 15) * 15;
            } else {
                return Math.round(seconds / 30) * 30;
            }
        };

        const generateCO2Tables = (initialBH, initialRecovery, weeks = 6) => {
            const tables = {};
            
            for (let week = 1; week <= weeks; week++) {
                const weekName = `Week ${week}`;
                const weeklyTable = [];
                
                const bhIncrement = Math.floor(initialBH * 0.3);
                const rawWeeklyBH = initialBH + (bhIncrement * (week - 1));
                const weeklyBH = roundTime(rawWeeklyBH);
                
                const recoveryDecrement = Math.floor(initialRecovery * 0.15);
                const rawBaseRecovery = Math.max(30, initialRecovery - (recoveryDecrement * (week - 1)));
                const baseRecovery = roundTime(rawBaseRecovery);
                
                for(let rep = 0; rep < 8; rep++) {
                    const recoveryReduction = Math.floor(baseRecovery * 0.05 * rep);
                    const rawFinalRecovery = Math.max(15, baseRecovery - recoveryReduction);
                    const finalRecovery = roundTime(rawFinalRecovery);
                    
                    weeklyTable.push({ bh: weeklyBH, rb: finalRecovery });
                }
                
                tables[weekName] = weeklyTable;
            }
            
            return tables;
        };

        // --- Audio Cue Hook ---
        const useAudio = () => {
            const audioContextRef = useRef(null);

            const ensureContext = useCallback(async () => {
                if (!audioContextRef.current) {
                    const Ctx = window.AudioContext || window.webkitAudioContext;
                    if (!Ctx) return null;
                    audioContextRef.current = new Ctx();
                }
                const ctx = audioContextRef.current;
                if (ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch (e) { }
                }
                return audioContextRef.current;
            }, []);

            const playSound = useCallback(async (type) => {
                const ctx = await ensureContext();
                if (!ctx) return;

                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                let duration = 0.6;

                if (type === 'start') {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0.5, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5);
                    duration = 0.5;
                } else if (type === 'end') {
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(880, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0.5, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1);
                    duration = 1.0;
                } else if (type === 'rep') {
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(440, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0.35, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.25);
                    duration = 0.25;
                }

                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + duration + 0.02);
            }, [ensureContext]);

            return { playSound, ensureContext };
        };

        // --- Circular Progress Bar Component ---
        const CircularProgressBar = ({ progress, color, size }) => {
            // progress: 1 means full circle, 0 means no stroke
            // SVG circle configuration
            const strokeWidth = 8;
            const radius = (size - strokeWidth) / 2;
            const circumference = 2 * Math.PI * radius;

            // Animate strokeDashoffset to empty circle anti-clockwise starting 12 o'clock
            // strokeDashoffset = circumference * progress (progress from 1 to 0)
            const dashOffset = circumference * (1 - progress);

            return (
                <svg
                    width={size}
                    height={size}
                    className="absolute inset-0"
                    aria-hidden="true"
                >
                    <circle
                        stroke={color}
                        fill="transparent"
                        strokeWidth={strokeWidth}
                        strokeLinecap="round"
                        r={radius}
                        cx={size / 2}
                        cy={size / 2}
                        style={{
                            strokeDasharray: circumference,
                            strokeDashoffset: dashOffset,
                            transition: 'stroke-dashoffset 1s linear'
                        }}
                    />
                </svg>
            );
        };

        // --- Components ---
        const CustomInputs = ({ initialBH, setInitialBH, initialRecovery, setInitialRecovery, isRunning, onUpdateTables }) => {
            const [bhInput, setBhInput] = useState(Math.floor(initialBH / 60));
            const [bhSeconds, setBhSeconds] = useState(initialBH % 60);
            const [recoveryInput, setRecoveryInput] = useState(Math.floor(initialRecovery / 60));
            const [recoverySeconds, setRecoverySeconds] = useState(initialRecovery % 60);

            const handleUpdate = () => {
                const newBH = bhInput * 60 + bhSeconds;
                const newRecovery = recoveryInput * 60 + recoverySeconds;
                
                if (newBH > 0 && newRecovery > 0) {
                    setInitialBH(newBH);
                    setInitialRecovery(newRecovery);
                    onUpdateTables(newBH, newRecovery);
                }
            };

            return (
                <div className="mb-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
                    <h3 className="text-lg font-semibold text-white mb-4 text-center">Custom Training Parameters</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label className="block text-sm font-medium text-gray-300 mb-2">Initial Breath Hold Time</label>
                            <div className="flex items-center space-x-2">
                                <input
                                    type="number"
                                    min="0"
                                    max="10"
                                    value={bhInput}
                                    onChange={(e) => setBhInput(parseInt(e.target.value) || 0)}
                                    disabled={isRunning}
                                    className="w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                                />
                                <span className="text-gray-400">min</span>
                                <input
                                    type="number"
                                    min="0"
                                    max="59"
                                    value={bhSeconds}
                                    onChange={(e) => setBhSeconds(parseInt(e.target.value) || 0)}
                                    disabled={isRunning}
                                    className="w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                                />
                                <span className="text-gray-400">sec</span>
                            </div>
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-gray-300 mb-2">Initial Recovery Time</label>
                            <div className="flex items-center space-x-2">
                                <input
                                    type="number"
                                    min="0"
                                    max="10"
                                    value={recoveryInput}
                                    onChange={(e) => setRecoveryInput(parseInt(e.target.value) || 0)}
                                    disabled={isRunning}
                                    className="w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                                />
                                <span className="text-gray-400">min</span>
                                <input
                                    type="number"
                                    min="0"
                                    max="59"
                                    value={recoverySeconds}
                                    onChange={(e) => setRecoverySeconds(parseInt(e.target.value) || 0)}
                                    disabled={isRunning}
                                    className="w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                                />
                                <span className="text-gray-400">sec</span>
                            </div>
                        </div>
                    </div>
                    <button
                        onClick={handleUpdate}
                        disabled={isRunning}
                        className="w-full bg-cyan-500 hover:bg-cyan-600 disabled:bg-gray-600 disabled:opacity-50 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                    >
                        Update Training Tables
                    </button>
                </div>
            );
        };

        const TimerDisplay = ({ time, phase, rep, totalReps, initialDuration }) => {
            // Calculate progress 1 to 0 as timer goes from full to 0
            const progress = initialDuration > 0 ? time / initialDuration : 0;

            // Color: keep same as existing fading ring border orange #fb923c (rgb 251,146,60)
            const color = 'rgba(251, 146, 60, 1)';

            // Size as existing fading ring container: max(72vw, 20rem) with border 8
            const size = 320; // Approx 20rem in px

            // Hide progress bar when time is zero
            const showProgress = time > 0;

            return (
                <div
                    className="relative flex flex-col items-center justify-center bg-gray-900 rounded-full w-[min(72vw,20rem)] h-[min(72vw,20rem)] md:w-80 md:h-80 mx-auto my-8 border-8 border-gray-800 shadow-lg"
                    aria-live="polite"
                    role="status"
                >
                    {showProgress && (
                        <CircularProgressBar progress={progress} color={color} size={size} />
                    )}
                    <div className="relative z-10 flex flex-col items-center justify-center">
                        <div className={`text-6xl md:text-8xl font-mono ${phase === 'BH' ? 'text-cyan-400' : 'text-green-400'}`}>
                            {formatTime(time)}
                        </div>
                        <div className="text-2xl md:text-3xl text-white mt-2">
                            {phase === 'BH' ? 'Breath Hold' : 'Recovery'}
                        </div>
                        <div className="text-lg md:text-xl text-gray-400 mt-1">
                            {`Rep: ${rep} / ${totalReps}`}
                        </div>
                    </div>
                </div>
            );
        };

        const SessionProgress = ({ currentRep, currentPhase, timeRemaining, initialDuration, totalReps }) => {
            const totalSteps = totalReps * 2;
            let completedBefore = currentRep * 2;
            let withinStepProgress = 0;

            if (initialDuration > 0) {
                withinStepProgress = (initialDuration - timeRemaining) / initialDuration;
            }

            let progressSteps = completedBefore;
            if (currentPhase === 'BH') {
                progressSteps += withinStepProgress;
            } else {
                progressSteps += 1 + withinStepProgress;
            }

            let progress = Math.max(0, Math.min(1, progressSteps / totalSteps));

            return (
                <div className="my-4 px-2">
                    <div className="flex items-center justify-between mb-2 text-sm text-gray-400">
                        <div>Session Progress</div>
                        <div>{`${Math.round(progress * 100)}%`}</div>
                    </div>
                    <div className="w-full h-4 bg-gray-800 rounded-full overflow-hidden border border-gray-700 shadow-inner">
                        <div
                            className="h-full rounded-full transition-all duration-500 ease-linear"
                            style={{
                                width: `${progress * 100}%`,
                                background: 'linear-gradient(90deg,#06b6d4,#10b981)'
                            }}
                        />
                    </div>
                </div>
            );
        };

        const TableSelector = ({ selectedTable, setSelectedTable, isRunning, co2Tables }) => (
            <div className="my-6">
                <label
                    htmlFor="table-select"
                    className="block text-lg font-medium text-gray-300 mb-2 text-center"
                >
                    Select CO2 Table
                </label>
                <select
                    id="table-select"
                    value={selectedTable}
                    onChange={(e) => {
                        if (!isRunning) setSelectedTable(e.target.value);
                    }}
                    disabled={isRunning}
                    className="block w-full max-w-xs mx-auto bg-gray-800 border border-gray-700 text-white text-lg rounded-lg focus:ring-cyan-500 focus:border-cyan-500 p-3 disabled:opacity-50"
                >
                    {Object.keys(co2Tables).map((tableName) => (
                        <option key={tableName} value={tableName}>
                            {tableName}
                        </option>
                    ))}
                </select>
            </div>
        );

        const Controls = ({ isRunning, onStart, onStop, onReset, resetDisabled }) => (
            <div className="flex justify-center items-center space-x-4">
                {!isRunning ? (
                    <button
                        onClick={onStart}
                        className="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 rounded-full text-2xl shadow-lg transform hover:scale-105 transition-transform"
                    >
                        Start
                    </button>
                ) : (
                    <button
                        onClick={onStop}
                        className="bg-red-500 hover:bg-red-600 text-white font-bold py-4 px-8 rounded-full text-2xl shadow-lg transform hover:scale-105 transition-transform"
                    >
                        Stop
                    </button>
                )}
                <button
                    onClick={onReset}
                    disabled={resetDisabled}
                    className={
                        'font-bold py-4 px-8 rounded-full text-2xl shadow-lg transform hover:scale-105 transition-transform ' +
                        (resetDisabled
                            ? 'bg-gray-600 text-white opacity-50 cursor-not-allowed hover:scale-100'
                            : 'bg-gray-500 hover:bg-gray-600 text-white')
                    }
                >
                    Reset
                </button>
            </div>
        );

        // --- Main App Component ---
        const App = () => {
            const [initialBH, setInitialBH] = useState(90);
            const [initialRecovery, setInitialRecovery] = useState(120);
            const [co2Tables, setCo2Tables] = useState(() => generateCO2Tables(90, 120));

            const defaultTable = 'Week 1';
            const [selectedTable, setSelectedTable] = useState(defaultTable);
            const [isRunning, setIsRunning] = useState(false);
            const [currentRep, setCurrentRep] = useState(0);
            const [currentPhase, setCurrentPhase] = useState('BH');
            const tableData = co2Tables[selectedTable];
            const totalReps = tableData.length;

            const initialFirst = tableData[0].bh;
            const [timeRemaining, setTimeRemaining] = useState(initialFirst);
            const [initialDuration, setInitialDuration] = useState(initialFirst);
            const [sessionFinished, setSessionFinished] = useState(false);

            const repRef = useRef(currentRep);
            const phaseRef = useRef(currentPhase);
            const timeRef = useRef(timeRemaining);
            const runningRef = useRef(isRunning);
            const intervalRef = useRef(null);

            const { playSound, ensureContext } = useAudio();

            useEffect(() => { repRef.current = currentRep; }, [currentRep]);
            useEffect(() => { phaseRef.current = currentPhase; }, [currentPhase]);
            useEffect(() => { timeRef.current = timeRemaining; }, [timeRemaining]);
            useEffect(() => { runningRef.current = isRunning; }, [isRunning]);

            const handleUpdateTables = useCallback((newBH, newRecovery) => {
                const newTables = generateCO2Tables(newBH, newRecovery);
                setCo2Tables(newTables);
                
                setSelectedTable('Week 1');
                const initial = newTables['Week 1'][0].bh;
                setIsRunning(false);
                setCurrentRep(0);
                setCurrentPhase('BH');
                setTimeRemaining(initial);
                setInitialDuration(initial);
                setSessionFinished(false);

                repRef.current = 0;
                phaseRef.current = 'BH';
                timeRef.current = initial;
            }, []);

            useEffect(() => {
                if (co2Tables[selectedTable]) {
                    const initial = co2Tables[selectedTable][0].bh;
                    setIsRunning(false);
                    setCurrentRep(0);
                    setCurrentPhase('BH');
                    setTimeRemaining(initial);
                    setInitialDuration(initial);
                    setSessionFinished(false);

                    repRef.current = 0;
                    phaseRef.current = 'BH';
                    timeRef.current = initial;
                }
            }, [selectedTable, co2Tables]);

            useEffect(() => {
                return () => {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                        intervalRef.current = null;
                    }
                };
            }, []);

            const tick = useCallback(() => {
                if (!runningRef.current) return;

                const next = Math.max(0, timeRef.current - 1);
                setTimeRemaining(next);
                timeRef.current = next;

                if (next === 0) {
                    const phase = phaseRef.current;
                    const rep = repRef.current;

                    if (phase === 'BH') {
                        playSound('end');
                        const nextDuration = tableData[rep].rb;
                        setCurrentPhase('RB');
                        phaseRef.current = 'RB';
                        setInitialDuration(nextDuration);
                        setTimeRemaining(nextDuration);
                        timeRef.current = nextDuration;
                    } else {
                        if (rep < totalReps - 1) {
                            playSound('rep');
                            const newRep = rep + 1;
                            repRef.current = newRep;
                            setCurrentRep(newRep);

                            const nextDuration = tableData[newRep].bh;
                            setCurrentPhase('BH');
                            phaseRef.current = 'BH';
                            setInitialDuration(nextDuration);
                            setTimeRemaining(nextDuration);
                            timeRef.current = nextDuration;
                        } else {
                            playSound('end');
                            setSessionFinished(true);
                            setIsRunning(false);
                            runningRef.current = false;

                            const initial = tableData[0].bh;
                            setCurrentRep(0);
                            repRef.current = 0;
                            setCurrentPhase('BH');
                            phaseRef.current = 'BH';
                            setInitialDuration(initial);
                            setTimeRemaining(initial);
                            timeRef.current = initial;

                            if (intervalRef.current) {
                                clearInterval(intervalRef.current);
                                intervalRef.current = null;
                            }
                        }
                    }
                }
            }, [playSound, tableData, totalReps]);

            useEffect(() => {
                if (isRunning && !intervalRef.current) {
                    ensureContext().catch(() => { });
                    intervalRef.current = setInterval(() => {
                        tick();
                    }, 1000);
                }

                if (!isRunning && intervalRef.current) {
                    clearInterval(intervalRef.current);
                    intervalRef.current = null;
                }

                return () => {
                    if (intervalRef.current && !runningRef.current) {
                        clearInterval(intervalRef.current);
                        intervalRef.current = null;
                    }
                };
            }, [isRunning, tick, ensureContext]);

            const handleStart = async () => {
                await ensureContext().catch(() => { });
                playSound('start');
                setIsRunning(true);
                runningRef.current = true;
                setSessionFinished(false);
            };

            const handleStop = () => {
                setIsRunning(false);
                runningRef.current = false;
                if (intervalRef.current) {
                    clearInterval(intervalRef.current);
                    intervalRef.current = null;
                }
            };

            const resetTimer = useCallback(() => {
                setIsRunning(false);
                runningRef.current = false;

                setCurrentRep(0);
                repRef.current = 0;

                setCurrentPhase('BH');
                phaseRef.current = 'BH';

                const initial = co2Tables[selectedTable][0].bh;
                setInitialDuration(initial);
                setTimeRemaining(initial);
                timeRef.current = initial;

                if (intervalRef.current) {
                    clearInterval(intervalRef.current);
                    intervalRef.current = null;
                }

                setSessionFinished(false);
            }, [selectedTable, co2Tables]);

            const handleReset = () => {
                if (sessionFinished) return;
                resetTimer();
                playSound('end');
            };

            return (
                <div className="bg-black min-h-screen flex flex-col items-center justify-center text-white p-4 font-sans">
                    <div className="w-full max-w-md mx-auto bg-gray-900/50 rounded-2xl shadow-2xl p-6 border border-gray-700">
                        <header className="text-center mb-4">
                            <h1 className="text-4xl font-bold text-cyan-400">CO₂ Training</h1>
                            <p className="text-gray-400">Custom Static Apnea Trainer</p>
                        </header>
                        <main>
                            <CustomInputs
                                initialBH={initialBH}
                                setInitialBH={setInitialBH}
                                initialRecovery={initialRecovery}
                                setInitialRecovery={setInitialRecovery}
                                isRunning={isRunning}
                                onUpdateTables={handleUpdateTables}
                            />
                            <TimerDisplay
                                time={timeRemaining}
                                phase={currentPhase}
                                rep={currentRep + 1}
                                totalReps={totalReps}
                                initialDuration={initialDuration}
                            />
                            <SessionProgress
                                currentRep={currentRep}
                                currentPhase={currentPhase}
                                timeRemaining={timeRemaining}
                                initialDuration={initialDuration}
                                totalReps={totalReps}
                            />
                            <TableSelector
                                selectedTable={selectedTable}
                                setSelectedTable={setSelectedTable}
                                isRunning={isRunning}
                                co2Tables={co2Tables}
                            />
                            <Controls
                                onStart={handleStart}
                                onStop={handleStop}
                                onReset={handleReset}
                                isRunning={isRunning}
                                resetDisabled={sessionFinished}
                            />
                        </main>
                        <footer className="text-center mt-8 text-gray-500 text-sm">
                            <p>Hold your breath during the 'Breath Hold' phase.</p>
                            <p>Breathe normally during the 'Recovery' phase.</p>
                            <p className="mt-2">Tables auto-generate based on your custom inputs.</p>
                        </footer>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
