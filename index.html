<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#000000" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>CO₂ Training - Custom Static Apnea Trainer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }
        body { 
            margin: 0; 
            padding: 0;
            overflow-x: hidden;
            touch-action: manipulation;
        }
        #root { 
            width: 100vw; 
            min-height: 100vh;
            min-height: 100dvh;
        }
        input, select, textarea {
            font-size: 16px;
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- Helper Functions ---
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        };

        const roundTime = (seconds) => {
            if (seconds <= 60) return Math.round(seconds / 5) * 5;
            if (seconds <= 300) return Math.round(seconds / 15) * 15;
            return Math.round(seconds / 30) * 30;
        };

        const generateCO2Tables = (initialBH, initialRecovery, weeks = 6) => {
            const tables = {};
            for (let week = 1; week <= weeks; week++) {
                const weekName = `Week ${week}`;
                const weeklyTable = [];
                const bhIncrement = Math.floor(initialBH * 0.3);
                const rawWeeklyBH = initialBH + (bhIncrement * (week - 1));
                const weeklyBH = roundTime(rawWeeklyBH);

                const recoveryDecrement = Math.floor(initialRecovery * 0.15);
                const rawBaseRecovery = Math.max(30, initialRecovery - (recoveryDecrement * (week - 1)));
                const baseRecovery = roundTime(rawBaseRecovery);

                for (let rep = 0; rep < 8; rep++) {
                    const recoveryReduction = Math.floor(baseRecovery * 0.05 * rep);
                    const rawFinalRecovery = Math.max(15, baseRecovery - recoveryReduction);
                    const finalRecovery = roundTime(rawFinalRecovery);

                    weeklyTable.push({
                        bh: weeklyBH,
                        rb: finalRecovery
                    });
                }
                tables[weekName] = weeklyTable;
            }
            return tables;
        };

        // --- Audio Cue Hook ---
        const useAudio = () => {
            const audioContextRef = useRef(null);

            const ensureContext = useCallback(async () => {
                if (!audioContextRef.current) {
                    const Ctx = window.AudioContext || window.webkitAudioContext;
                    if (!Ctx) return null;
                    audioContextRef.current = new Ctx();
                }
                const ctx = audioContextRef.current;
                if (ctx.state === 'suspended') {
                    try { 
                        await ctx.resume(); 
                    } catch (e) { 
                        console.warn('Audio context resume failed:', e);
                    }
                }
                return ctx;
            }, []);

            const playSound = useCallback(async (type) => {
                const ctx = await ensureContext();
                if (!ctx) return;

                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                let duration = 0.6;

                switch(type) {
                    case 'start':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(523.25, ctx.currentTime);
                        gainNode.gain.setValueAtTime(0.5, ctx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5);
                        duration = 0.5;
                        break;
                    case 'end':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(880, ctx.currentTime);
                        gainNode.gain.setValueAtTime(0.5, ctx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1);
                        duration = 1.0;
                        break;
                    case 'rep':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(440, ctx.currentTime);
                        gainNode.gain.setValueAtTime(0.35, ctx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.25);
                        duration = 0.25;
                        break;
                }

                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + duration + 0.02);
            }, [ensureContext]);

            return { playSound, ensureContext };
        };

        // --- Components ---
        const CustomInputs = ({ initialBH, setInitialBH, initialRecovery, setInitialRecovery, isRunning, onUpdateTables }) => {
            const [bhInput, setBhInput] = useState(Math.floor(initialBH / 60));
            const [bhSeconds, setBhSeconds] = useState(initialBH % 60);
            const [recoveryInput, setRecoveryInput] = useState(Math.floor(initialRecovery / 60));
            const [recoverySeconds, setRecoverySeconds] = useState(initialRecovery % 60);

            const handleUpdate = () => {
                const newBH = bhInput * 60 + bhSeconds;
                const newRecovery = recoveryInput * 60 + recoverySeconds;

                if (newBH > 0 && newRecovery > 0) {
                    setInitialBH(newBH);
                    setInitialRecovery(newRecovery);
                    onUpdateTables(newBH, newRecovery);
                }
            };

            return React.createElement('div', { className: "mb-4 sm:mb-6 p-3 sm:p-4 bg-gray-800 rounded-lg border border-gray-700" },
                React.createElement('h3', { className: "text-base sm:text-lg font-semibold text-white mb-3 sm:mb-4 text-center" }, "Custom Training Parameters"),

                React.createElement('div', { className: "space-y-3 sm:space-y-0 sm:grid sm:grid-cols-2 sm:gap-4 mb-3 sm:mb-4" },
                    React.createElement('div', null,
                        React.createElement('label', { className: "block text-xs sm:text-sm font-medium text-gray-300 mb-2" }, "Initial Breath Hold Time"),
                        React.createElement('div', { className: "flex items-center justify-center space-x-2" },
                            React.createElement('input', {
                                type: "number",
                                min: "0",
                                max: "10",
                                value: bhInput,
                                onChange: (e) => setBhInput(parseInt(e.target.value) || 0),
                                disabled: isRunning,
                                className: "w-14 sm:w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                            }),
                            React.createElement('span', { className: "text-gray-400 text-sm" }, "min"),
                            React.createElement('input', {
                                type: "number",
                                min: "0",
                                max: "59",
                                value: bhSeconds,
                                onChange: (e) => setBhSeconds(parseInt(e.target.value) || 0),
                                disabled: isRunning,
                                className: "w-14 sm:w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                            }),
                            React.createElement('span', { className: "text-gray-400 text-sm" }, "sec")
                        )
                    ),

                    React.createElement('div', null,
                        React.createElement('label', { className: "block text-xs sm:text-sm font-medium text-gray-300 mb-2" }, "Initial Recovery Time"),
                        React.createElement('div', { className: "flex items-center justify-center space-x-2" },
                            React.createElement('input', {
                                type: "number",
                                min: "0",
                                max: "10",
                                value: recoveryInput,
                                onChange: (e) => setRecoveryInput(parseInt(e.target.value) || 0),
                                disabled: isRunning,
                                className: "w-14 sm:w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                            }),
                            React.createElement('span', { className: "text-gray-400 text-sm" }, "min"),
                            React.createElement('input', {
                                type: "number",
                                min: "0",
                                max: "59",
                                value: recoverySeconds,
                                onChange: (e) => setRecoverySeconds(parseInt(e.target.value) || 0),
                                disabled: isRunning,
                                className: "w-14 sm:w-16 bg-gray-700 border border-gray-600 text-white text-center rounded p-2 disabled:opacity-50"
                            }),
                            React.createElement('span', { className: "text-gray-400 text-sm" }, "sec")
                        )
                    )
                ),

                React.createElement('button', {
                    onClick: handleUpdate,
                    disabled: isRunning,
                    className: "w-full bg-cyan-500 hover:bg-cyan-600 active:bg-cyan-700 disabled:bg-gray-600 disabled:opacity-50 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, "Update Training Tables")
            );
        };

        const TimerDisplay = ({ time, phase, rep, totalReps, initialDuration }) => {
            const radius = 75;
            const stroke = 10;
            const normalizedRadius = radius - stroke / 2;
            const circumference = normalizedRadius * 2 * Math.PI;
            const progress = initialDuration > 0 ? time / initialDuration : 0;
            const strokeDashoffset = circumference - progress * circumference;

            return React.createElement('div', {
                className: "relative flex flex-col items-center justify-center bg-gray-900 rounded-full w-60 h-60 sm:w-72 sm:h-72 md:w-80 md:h-80 mx-auto my-4 sm:my-6 md:my-8 border-4 sm:border-6 md:border-8 border-gray-800 shadow-lg",
                'aria-live': "polite",
                role: "status"
            },
                React.createElement('svg', {
                    height: 2 * radius,
                    width: 2 * radius,
                    className: "absolute",
                    style: {
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%) rotate(-90deg)'
                    }
                },
                    React.createElement('circle', {
                        stroke: '#4b5563',
                        fill: 'transparent',
                        strokeWidth: stroke,
                        r: normalizedRadius,
                        cx: radius,
                        cy: radius
                    }),
                    React.createElement('circle', {
                        stroke: '#fb923c',
                        fill: 'transparent',
                        strokeWidth: stroke,
                        strokeDasharray: `${circumference} ${circumference}`,
                        strokeDashoffset: strokeDashoffset,
                        strokeLinecap: 'round',
                        r: normalizedRadius,
                        cx: radius,
                        cy: radius,
                        style: {
                            transition: 'stroke-dashoffset 1s linear',
                            filter: 'drop-shadow(0 0 6px rgba(251,146,60,0.7))'
                        }
                    })
                ),
                React.createElement('div', { className: "relative z-10 flex flex-col items-center justify-center px-2" },
                    React.createElement('div', { className: `text-5xl sm:text-6xl md:text-8xl font-mono ${phase === 'BH' ? 'text-cyan-400' : 'text-green-400'}` },
                        formatTime(time)
                    ),
                    React.createElement('div', { className: "text-xl sm:text-2xl md:text-3xl text-white mt-1 sm:mt-2" },
                        phase === 'BH' ? 'Breath Hold' : 'Recovery'
                    ),
                    React.createElement('div', { className: "text-base sm:text-lg md:text-xl text-gray-400 mt-0.5 sm:mt-1" },
                        `Rep: ${rep} / ${totalReps}`
                    )
                )
            );
        };

        const SessionProgress = ({ currentRep, currentPhase, timeRemaining, initialDuration, totalReps }) => {
            const progress = useMemo(() => {
                const totalSteps = totalReps * 2;
                let completedBefore = currentRep * 2;
                let withinStepProgress = 0;

                if (initialDuration > 0) {
                    withinStepProgress = (initialDuration - timeRemaining) / initialDuration;
                }

                let progressSteps = completedBefore;
                if (currentPhase === 'BH') {
                    progressSteps += withinStepProgress;
                } else {
                    progressSteps += 1 + withinStepProgress;
                }

                return Math.max(0, Math.min(1, progressSteps / totalSteps));
            }, [currentRep, currentPhase, timeRemaining, initialDuration, totalReps]);

            return React.createElement('div', { className: "my-3 sm:my-4 px-2" },
                React.createElement('div', { className: "flex items-center justify-between mb-2 text-xs sm:text-sm text-gray-400" },
                    React.createElement('div', null, "Session Progress"),
                    React.createElement('div', null, `${Math.round(progress * 100)}%`)
                ),
                React.createElement('div', { className: "w-full h-3 sm:h-4 bg-gray-800 rounded-full overflow-hidden border border-gray-700 shadow-inner" },
                    React.createElement('div', {
                        className: "h-full rounded-full transition-all duration-500 ease-linear",
                        style: { 
                            width: `${progress * 100}%`, 
                            background: 'linear-gradient(90deg,#06b6d4,#10b981)' 
                        }
                    })
                )
            );
        };

        const TableSelector = ({ selectedTable, setSelectedTable, isRunning, co2Tables }) => (
            React.createElement('div', { className: "my-4 sm:my-6" },
                React.createElement('label', { 
                    htmlFor: "table-select", 
                    className: "block text-base sm:text-lg font-medium text-gray-300 mb-2 text-center" 
                }, "Select CO2 Table"),
                React.createElement('select', {
                    id: "table-select",
                    value: selectedTable,
                    onChange: (e) => setSelectedTable(e.target.value),
                    disabled: isRunning,
                    className: "block w-full max-w-xs mx-auto bg-gray-800 border border-gray-700 text-white text-base sm:text-lg rounded-lg focus:ring-cyan-500 focus:border-cyan-500 p-2 sm:p-3 disabled:opacity-50"
                },
                    Object.keys(co2Tables).map((tableName) => 
                        React.createElement('option', { key: tableName, value: tableName }, tableName)
                    )
                )
            )
        );

        const Controls = ({ isRunning, onStart, onStop, onReset, resetDisabled }) => (
            React.createElement('div', { className: "flex justify-center items-center space-x-3 sm:space-x-4" },
                !isRunning ? 
                    React.createElement('button', {
                        onClick: onStart,
                        className: "bg-green-500 hover:bg-green-600 active:bg-green-700 text-white font-bold py-3 px-6 sm:py-4 sm:px-8 rounded-full text-xl sm:text-2xl shadow-lg transform active:scale-95 transition-transform"
                    }, "Start") :
                    React.createElement('button', {
                        onClick: onStop,
                        className: "bg-red-500 hover:bg-red-600 active:bg-red-700 text-white font-bold py-3 px-6 sm:py-4 sm:px-8 rounded-full text-xl sm:text-2xl shadow-lg transform active:scale-95 transition-transform"
                    }, "Stop"),
                React.createElement('button', {
                    onClick: onReset,
                    disabled: resetDisabled,
                    className: `font-bold py-3 px-6 sm:py-4 sm:px-8 rounded-full text-xl sm:text-2xl shadow-lg transition-transform ` +
                        (resetDisabled
                            ? 'bg-gray-600 text-white opacity-50 cursor-not-allowed'
                            : 'bg-gray-500 hover:bg-gray-600 active:bg-gray-700 transform active:scale-95')
                }, "Reset")
            )
        );

        // --- Main App Component ---
        const App = () => {
            const [initialBH, setInitialBH] = useState(90);
            const [initialRecovery, setInitialRecovery] = useState(120);
            const [co2Tables, setCo2Tables] = useState(() => generateCO2Tables(90, 120));

            const defaultTable = 'Week 1';
            const [selectedTable, setSelectedTable] = useState(defaultTable);
            const [isRunning, setIsRunning] = useState(false);
            const [currentRep, setCurrentRep] = useState(0);
            const [currentPhase, setCurrentPhase] = useState('BH');
            const tableData = co2Tables[selectedTable];
            const totalReps = tableData.length;

            const initialFirst = tableData[0].bh;
            const [timeRemaining, setTimeRemaining] = useState(initialFirst);
            const [initialDuration, setInitialDuration] = useState(initialFirst);
            const [sessionFinished, setSessionFinished] = useState(false);

            const repRef = useRef(currentRep);
            const phaseRef = useRef(currentPhase);
            const timeRef = useRef(timeRemaining);
            const runningRef = useRef(isRunning);
            const intervalRef = useRef(null);

            const { playSound, ensureContext } = useAudio();

            useEffect(() => { repRef.current = currentRep; }, [currentRep]);
            useEffect(() => { phaseRef.current = currentPhase; }, [currentPhase]);
            useEffect(() => { timeRef.current = timeRemaining; }, [timeRemaining]);
            useEffect(() => { runningRef.current = isRunning; }, [isRunning]);

            const handleUpdateTables = useCallback((newBH, newRecovery) => {
                const newTables = generateCO2Tables(newBH, newRecovery);
                setCo2Tables(newTables);

                setSelectedTable('Week 1');
                const initial = newTables['Week 1'][0].bh;
                setIsRunning(false);
                setCurrentRep(0);
                setCurrentPhase('BH');
                setTimeRemaining(initial);
                setInitialDuration(initial);
                setSessionFinished(false);

                repRef.current = 0;
                phaseRef.current = 'BH';
                timeRef.current = initial;
            }, []);

            useEffect(() => {
                if (co2Tables[selectedTable]) {
                    const initial = co2Tables[selectedTable][0].bh;
                    setIsRunning(false);
                    setCurrentRep(0);
                    setCurrentPhase('BH');
                    setTimeRemaining(initial);
                    setInitialDuration(initial);
                    setSessionFinished(false);

                    repRef.current = 0;
                    phaseRef.current = 'BH';
                    timeRef.current = initial;
                }
            }, [selectedTable, co2Tables]);

            useEffect(() => {
                return () => {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                        intervalRef.current = null;
                    }
                };
            }, []);

            const tick = useCallback(() => {
                if (!runningRef.current) return;

                const next = Math.max(0, timeRef.current - 1);
                setTimeRemaining(next);
                timeRef.current = next;

                if (next === 0) {
                    const phase = phaseRef.current;
                    const rep = repRef.current;

                    if (phase === 'BH') {
                        playSound('end');
                        const nextDuration = tableData[rep].rb;
                        setCurrentPhase('RB');
                        phaseRef.current = 'RB';
                        setInitialDuration(nextDuration);
                        setTimeRemaining(nextDuration);
                        timeRef.current = nextDuration;
                    } else {
                        if (rep < totalReps - 1) {
                            playSound('rep');
                            const newRep = rep + 1;
                            repRef.current = newRep;
                            setCurrentRep(newRep);

                            const nextDuration = tableData[newRep].bh;
                            setCurrentPhase('BH');
                            phaseRef.current = 'BH';
                            setInitialDuration(nextDuration);
                            setTimeRemaining(nextDuration);
                            timeRef.current = nextDuration;
                        } else {
                            playSound('end');
                            setSessionFinished(true);
                            setIsRunning(false);
                            runningRef.current = false;

                            const initial = tableData[0].bh;
                            setCurrentRep(0);
                            repRef.current = 0;
                            setCurrentPhase('BH');
                            phaseRef.current = 'BH';
                            setInitialDuration(initial);
                            setTimeRemaining(initial);
                            timeRef.current = initial;

                            if (intervalRef.current) {
                                clearInterval(intervalRef.current);
                                intervalRef.current = null;
                            }
                        }
                    }
                }
            }, [playSound, tableData, totalReps]);

            useEffect(() => {
                if (isRunning && !intervalRef.current) {
                    ensureContext().catch(() => {});
                    intervalRef.current = setInterval(tick, 1000);
                } else if (!isRunning && intervalRef.current) {
                    clearInterval(intervalRef.current);
                    intervalRef.current = null;
                }

                return () => {
                    if (intervalRef.current && !runningRef.current) {
                        clearInterval(intervalRef.current);
                        intervalRef.current = null;
                    }
                };
            }, [isRunning, tick, ensureContext]);

            const handleStart = async () => {
                await ensureContext().catch(() => {});
                playSound('start');
                setIsRunning(true);
                runningRef.current = true;
                setSessionFinished(false);
            };

            const handleStop = () => {
                setIsRunning(false);
                runningRef.current = false;
                if (intervalRef.current) {
                    clearInterval(intervalRef.current);
                    intervalRef.current = null;
                }
            };

            const resetTimer = useCallback(() => {
                setIsRunning(false);
                runningRef.current = false;

                setCurrentRep(0);
                repRef.current = 0;

                setCurrentPhase('BH');
                phaseRef.current = 'BH';

                const initial = co2Tables[selectedTable][0].bh;
                setInitialDuration(initial);
                setTimeRemaining(initial);
                timeRef.current = initial;

                if (intervalRef.current) {
                    clearInterval(intervalRef.current);
                    intervalRef.current = null;
                }

                setSessionFinished(false);
            }, [selectedTable, co2Tables]);

            const handleReset = () => {
                if (sessionFinished) return;
                resetTimer();
                playSound('end');
            };

            return React.createElement('div', {
                className: "bg-black min-h-screen min-h-[100dvh] flex flex-col items-center justify-start py-3 sm:py-0 sm:justify-center text-white px-3 sm:px-4 font-sans overflow-y-auto"
            },
                React.createElement('div', {
                    className: "w-full max-w-md mx-auto bg-gray-900/50 rounded-2xl shadow-2xl p-4 sm:p-6 border border-gray-700"
                },
                    React.createElement('header', { className: "text-center mb-3 sm:mb-4" },
                        React.createElement('h1', { className: "text-3xl sm:text-4xl font-bold text-cyan-400" }, "CO₂ Training"),
                        React.createElement('p', { className: "text-sm sm:text-base text-gray-400" }, "Custom Static Apnea Trainer")
                    ),

                    React.createElement('main', null,
                        React.createElement(CustomInputs, {
                            initialBH: initialBH,
                            setInitialBH: setInitialBH,
                            initialRecovery: initialRecovery,
                            setInitialRecovery: setInitialRecovery,
                            isRunning: isRunning,
                            onUpdateTables: handleUpdateTables
                        }),

                        React.createElement(TimerDisplay, {
                            time: timeRemaining,
                            phase: currentPhase,
                            rep: currentRep + 1,
                            totalReps: totalReps,
                            initialDuration: initialDuration
                        }),

                        React.createElement(SessionProgress, {
                            currentRep: currentRep,
                            currentPhase: currentPhase,
                            timeRemaining: timeRemaining,
                            initialDuration: initialDuration,
                            totalReps: totalReps
                        }),

                        React.createElement(TableSelector, {
                            selectedTable: selectedTable,
                            setSelectedTable: (val) => {
                                if (isRunning) return;
                                setSelectedTable(val);
                            },
                            isRunning: isRunning,
                            co2Tables: co2Tables
                        }),

                        React.createElement(Controls, {
                            onStart: handleStart,
                            onStop: handleStop,
                            onReset: handleReset,
                            isRunning: isRunning,
                            resetDisabled: sessionFinished
                        })
                    ),

                    React.createElement('footer', { className: "text-center mt-4 sm:mt-8 text-gray-500 text-xs sm:text-sm" },
                        React.createElement('p', null, "Hold your breath during the 'Breath Hold' phase."),
                        React.createElement('p', null, "Breathe normally during the 'Recovery' phase."),
                        React.createElement('p', { className: "mt-2" }, "Tables auto-generate based on your custom inputs.")
                    )
                )
            );
        };

        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>
